**原文：[ECMAScript 5 Objects and Properties](http://ejohn.org/blog/ecmascript-5-objects-and-properties/)**

ECMAScript 5 is on its way. Rising from the ashes of ECMAScript 4, which got scaled way back and became ECMAScript 3.1, which was then re-named ECMAScript 5 (more details)- comes a new layer of functionality built on top of our lovable ECMAScript 3.

ECMAScript 5正在走在它向前发展的道路上。ECMAScript 4被取消了，其中在能够兼容于ECMAScript 3语法的前提下，可以实现的特性被整合成ECMAScript 3.1，随后ES 3.1又被重命名成ECMAScript 5（更多详细信息请参考[这篇WIKI](http://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition)）。

There are a few new APIs included in the specification but the most interesting functionality comes into play in the Object/Property code. This new code gives you the ability to dramatically affect how users will be able to interact with your objects, allowing you to provide getters and setters, prevent enumeration, manipulation, or deletion, and even prevent the addition of new properties. In short: You will be able to replicate and expand upon the existing JavaScript-based APIs (such as the DOM) using nothing but JavaScript itself.

标准文档添加了许多新的API但其中最有趣应该是Object/Property提供的新功能。这些新功能使你可以在运行时动态影响到其他开发者的代码与你的对象之间的交互方式，允许你提供getter以及setter属性访问器，阻止for in枚举对象属性，修改，删除甚至能禁止添加新的属性到你的对象上。简单来说，就是你可以通过JavaScript本身对那基于JavaScript构建的API进行复制和拓展。

###Objects###
A new feature of ECMAScript 5 is that the extensibility of objects can now be toggled. Turning off extensibility can prevent new properties from getting added to an object.

ES5的一个新特性就是对象的可拓展性是可以控制的。关闭对象的可拓展性可以禁止新属性添加到对象上。

ES5 provides two methods for manipulating and verifying the extensibility of objects.

ES5提供了两个方法修改和验证对象的可拓展性。

	Object.preventExtensions( obj )

	Object.isExtensible( obj )

preventExtensions locks down an object and prevents and future property additions from occurring. isExtensible is a way to determine the current extensibility of an object.

preventExtensions方法锁住对象并且禁止以后添加新属性到对象上。isExtensible则可以用来验证当前对象是否可以进行拓展。

**使用示例：**

	var obj = {};
 
	obj.name = "John";
	print( obj.name );
	// John
 
	print( Object.isExtensible( obj ) );
	// true
 
	Object.preventExtensions( obj );
 
	obj.url = "http://ejohn.org/"; // Exception in strict mode
 
	print( Object.isExtensible( obj ) );
	// false

###Properties and Descriptors###
Properties have been completely overhauled. No longer are they the simple value associated with an object – you now have complete control over how they can behave. With this power, though, comes increased complexity.

javascript的属性系统已经被广大开发者详尽的研究过了。属性已经不再是简单的值和对象之间的关联——现在你可以完全控制属性的行为了。尽管这一特性给开发带来了一些复杂性。

Object properties are broken down into two portions.

对象的属性系统现在分成了两个部分。

For the actual “meat” of a property there are two possibilities: A Value (a “Data” property – this is the traditional value that we know and love from ECMAScript 3) or a Getter and Setter (an “Accessor” property – we know this from some modern browsers, like Gecko and WebKit).

实际上一个属性的值只有两种可能：值，也就是数据属性；或者是一个Getter和Setter（访问器属性——我们可以从现代浏览器知道这一概念，比如Gecko和Webkit）。

*	值。包含了属性对应的数据。
*	Get访问器。 访问对象属性值的时候，Get方法将会被调用。
*	Set访问器。 当修改对象属性值的时候，Set方法将会被调用。

另外，属性也可以是：

*	Writable. 如果Writable为false的话，对应属性的值不可变。
*	Configurable。如果Configurable为false的话，任何删除属性或者修改属性元数据（Writable, Configurable, 或者Enumerable）都会失败。
*	Enumerable. 如果Enumerable为true，则属性可以在for..in循环里枚举。

Altogether these various attributes make up a property descriptor. For example, a simple descriptor might look something like the following:

上述的特性，Getter，Setter以及Writable等合在一起构成了属性描述。一个简单的属性描述如下所示：

	{
	  value: "test",
	  writable: true,
	  enumerable: true,
	  configurable: true
	}

The three attributes (writable, enumerable, and configurable) are all optional and all default to true. Thus, the only property that you’ll need to provide will be, either, value or get and set.

其中那三个属性（writable, enumerable, 和 configurable）都是可选参数，并且默认值都是true。因此，对于属性描述，你需要提供的要么是数据类型的值，不然就是get或者set方法了。

You can use the new Object.getOwnPropertyDescriptor method to get at this information for an existing property on an object.

通过调用Object.getOwnPropertyDescriptor这个新的方法，你可以对象已经存在的属性的属性描述。

**	Object.getOwnPropertyDescriptor( obj, prop )**

This method allows you to access the descriptor of a property. This method is the only way to get at this information (it is, otherwise, not available to the user – these don’t exist as visible properties on the property, they’re stored internally in the ECMAScript engine).

这个方法允许你访问属性的属性描述。同时这也是访问属性描述的唯一方法（因为属性描述并非以可见属性的形式存储在属性上，而是由ECMAScript运行时内部维护）。

**代码示例：**

	var obj = { foo: "test" };
 
	print(JSON.stringify(
	  Object.getOwnPropertyDescriptor( obj, "foo" )
	));
	// {"value": "test", "writable": true,
	//  "enumerable": true, "configurable": true}

**	Object.defineProperty( obj, prop, desc )**

This method allows you to define a new property on an object (or change the descriptor of an existing property). This method accepts a property descriptor and uses it to initialize (or update) a property.

通过这个方法，你可以给对象定义一个新的属性（或者修改属性的属性描述）。这个方法接受一个属性描述对象作为参数并且初始化或者更新属性。

**使用示例：**

	var obj = {};
 
	Object.defineProperty( obj, "value", {
	  value: true,
	  writable: false,
	  enumerable: true,
	  configurable: true
	});
 
	(function(){
	  var name = "John";
 
	  Object.defineProperty( obj, "name", {
	    get: function(){ return name; },
	    set: function(value){ name = value; }
	  });
	})();
 
	print( obj.value )
	// true
 
	print( obj.name );
	// John
 
	obj.name = "Ted";
	print( obj.name );
	// Ted
 
	for ( var prop in obj ) {
	  print( prop );
	}
	// value
	// name
 
	obj.value = false; // Exception if in strict mode
 
	Object.defineProperty( obj, "value", {
	  writable: true,
	  configurable: false
	});
 
	obj.value = false;
	print( obj.value );
	// false
 
	delete obj.value; // Exception

Object.defineProperty is a core method of the new version of ECMAScript. Virtually all the other major features rely upon this method existing.

Object.defineProperty是新版本ECMAScript的一个核心的方法。事实上其他主要的特性都依赖于这个方法的存在。

**	Object.defineProperties( obj, props )**

A means of defining a number of properties simultaneously (instead of individually).

这是一个可以同时定义复数个属性的方法。

**示例实现：**

	Object.defineProperties = function( obj, props ) {
	  for ( var prop in props ) {
	    Object.defineProperty( obj, prop, props[prop] );
	  }
	};

**使用示例：**

	var obj = {};
 
	Object.defineProperties(obj, {
	  "value": {
	    value: true,
	    writable: false
	  },
	  "name": {
	    value: "John",
	    writable: false
	  }
	});


Property descriptors (and their associated methods) is probably the most important new feature of ECMAScript 5. It gives developers the ability to have fine-grained control of their objects, prevent undesired tinkering, and maintaining a unified web-compatible API.

属性描述（以及和属性描述相关的方法）可能是ES 5最重要的特性，没有之一。这些特性给与开发者从细粒度上控制对象的能力，阻止了不必要的修补，维护了一个统一的浏览器兼容API。

###New Features###
Building on top of these new additions some interesting new features have been introduced into the language.

The following two methods are very useful for collecting arrays of all the properties on an object.

Object.keys( obj )

Returns an array of strings representing all the enumerable property names of the object. This is identical to the method included in Prototype.js.

Example Implementation:

Object.keys = function( obj ) {
  var array = new Array();
  for ( var prop in obj ) {
    if ( obj.hasOwnProperty( prop ) ) {
      array.push( prop );
    }
  }
  return array;
};
Example Usage:

var obj = { name: "John", url: "http://ejohn.org/" };
 
print( Object.keys(obj).join(", ") );
// name, url
Object.getOwnPropertyNames( obj )

Nearly identical to Object.keys but returns all property names of the object (not just the enumerable ones).

An implementation isn’t possible with regular ECMAScript since non-enumerable properties can’t be enumerated. The output and usage is otherwise identical to Object.keys.

Object.create( proto, props )

Creates a new object whose prototype is equal to the value of proto and whose properties are set via Object.defineProperties( props ).

A simple implementation would look like this (requires the new Object.defineProperties method).

Example Implementation: (by Ben Newman)

Object.create = function( proto, props ) {
  var ctor = function( ps ) {
    if ( ps )
      Object.defineProperties( this, ps );
  };
  ctor.prototype = proto;
  return new ctor( props );
};
Other implementation:

Object.create = function( proto, props ) {
  var obj = new Object();
  obj.__proto__ = proto;
 
  if ( typeof props !== "undefined" ) {
    Object.defineProperties( obj, props );
  }
 
  return obj;
};
Note: The above code makes use of the Mozilla-specific __proto__ property. This property gives you access to the internal prototype of an object – and allows you to set its value, as well. The ES5 method Object.getPrototypeOf allows you to access this value but not set its value – thus the above method cannot be implement in a generic, spec-compatible, manner.

I discussed Object.getPrototypeOf previously so I won’t bother discussing it again here.

Example Usage:

function User(){}
User.prototype.name = "Anonymous";
User.prototype.url = "http://google.com/";
 
var john = Object.create(new User(), {
  name: { value: "John", writable: false },
  url: { value: "http://google.com/" }
});
 
print( john.name );
// John
 
john.name = "Ted"; // Exception if in strict mode
Object.seal( obj )
Object.isSealed( obj )

Sealing an object prevents other code from deleting, or changing the descriptors of, any of the object’s properties – and from adding new properties.

Example Implementation:

Object.seal = function( obj ) {
  var props = Object.getOwnPropertyNames( obj );
 
  for ( var i = 0; i < props.length; i++ ) {
    var desc = Object.getOwnPropertyDescriptor( obj, props[i] );
   
    desc.configurable = false;
    Object.defineProperty( obj, props[i], desc );
  }
 
  return Object.preventExtensions( obj );
};
You would seal an object if you want its existing properties to stay intact, without allowing for new additions, but while still allowing the user to write to or edit the properties.

Object.freeze( obj )
Object.isFrozen( obj )

Freezing an object is nearly identical to sealing it but with the addition of making the properties un-editable.

Example Implementation:

Object.freeze = function( obj ) {
  var props = Object.getOwnPropertyNames( obj );
 
  for ( var i = 0; i < props.length; i++ ) {
    var desc = Object.getOwnPropertyDescriptor( obj, props[i] );
   
    if ( "value" in desc ) {
      desc.writable = false;
    }
   
    desc.configurable = false;
    Object.defineProperty( obj, props[i], desc );
  }
 
  return Object.preventExtensions( obj );
};
Freezing an object is the ultimate form of lock-down. Once an object has been frozen it cannot be unfrozen – nor can it be tampered in any manner. This is the best way to make sure that your objects will stay exactly as you left them, indefinitely.

All together these changes are very exciting, they provide you with an unprecedented level of control over the objects that you produce. The best aspect, though, is that you will be able to use these features to build larger and more complex features in pure ECMAScript (such as building new DOM modules, or moving more browser APIs into pure-JavaScript). And since all the browsers are on board this is absolutely something that we can look forward to.